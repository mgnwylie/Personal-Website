if(verbose) cat(address18,"\n")
u <- url(address18)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
# builds url to access API
url <- function(address, return.call = "json", sensor = "false" , key) {
root <- "https://maps.google.com/maps/api/geocode/"
u <- paste(root, return.call, "?address=", address, "&sensor=", sensor, "&key=" ,
key , sep = "")
return(URLencode(u))
}
# Function to parse the results:
geocode <- function(address, api.key , verbose=FALSE) {
if(verbose) cat(address,"\n")
u <- url(address , key = api.key)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
#abe sent this.
key <- "AIzaSyDdNyvzi87jUh-E8h_ce2MbPnwvcuEIme0"
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations_geocode) <- c("lat","lng","location_type", "formatted")
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
install.packages("gitpass")
source("https://install-github.me/gaborcsardi/secret")
library(secret)
install.packages("keyring")
library(keyring)
key_set("AIzaSyC-lAH7nmzkNtZAYLZxule5yn8CawnVWIY")
key_set("googleapi")
key <- key_get("googleapi")
location18 <- condamnes2018 %>% pull(addresses)
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
library(RCurl)
library(RJSONIO)
library(plyr)
library(mapsapi)
library(keyring)
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
key_set("googleapi")
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
#sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
#edit data
# I need the csv files to have geographic coordinates.
# I'll geolocate them, but first I have to merge their house numbers and roads
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
# geolocate the addresses
# this makes two functions to use in geocoding.
# builds url to access API
url <- function(address, return.call = "json", sensor = "false" , key) {
root <- "https://maps.google.com/maps/api/geocode/"
u <- paste(root, return.call, "?address=", address, "&sensor=", sensor, "&key=" ,
key , sep = "")
return(URLencode(u))
}
# Function to parse the results:
geocode <- function(address, api.key , verbose=FALSE) {
if(verbose) cat(address,"\n")
u <- url(address , key = api.key)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
key <- key_get("googleapi")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
# to do:
# - add that the addresses are in Quebec.
# join based on formatted field
# - use gitpass to hide api key
key_set("googleapi")
key <- key_get('googleapi')
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
keyring_create("Rcredentials")
key_set("googleapi", keyring ="Rcredentials")
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
library(RCurl)
library(RJSONIO)
library(plyr)
library(mapsapi)
library(keyring)
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
keyring_create("Rcredentials")
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
#sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
#edit data
# I need the csv files to have geographic coordinates.
# I'll geolocate them, but first I have to merge their house numbers and roads
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, " Montreal") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, " Montreal") #ensures geocoded to Montreal
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
library(RCurl)
library(RJSONIO)
library(plyr)
library(mapsapi)
library(keyring)
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
keyring_create("Rcredentials")
map(locations18_geocode)
library(sf)
library(raster)
install.packages(c("raster", "spData", "spDataLarge"))
library(tmap)    # for static and interactive maps
library(sf)
library(raster)
library(dplyr)
library(spData)
#library(spDataLarge) #not available for this version of R (tutorial on Lovelace)
library(tmap)    # for static and interactive maps
install.packages(c("tmap", "shiny"))
library(sf)
library(raster)
library(dplyr)
library(spData)
#library(spDataLarge) #not available for this version of R (tutorial on Lovelace)
library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(mapview) # for interactive maps
install.packages("mapview")
library(mapview) # for interactive maps
library(ggplot2) # tidyverse data visualization package
library(shiny)   # for web applications
install.packages("rworldmap")
library(rworldmap)
# check geo-locations on maps
newmap <- getMap(resolution = "low")
View(locations18_geocode)
plot(newmap, xlim = c(-125, 60), ylim = c(30, 70), asp = 1)
plot(newmap, xlim = c(-60, 125), ylim = c(30, 70), asp = 1)
plot(newmap, xlim = c(), ylim = c(), asp = 1)
points(locations18_geocode$V1, locations18_geocode$V2, col = "red", cex = .6)
points(locations18_geocode$V1, locations18_geocode$V2, col = "red", cex = .6)
plot(newmap, xlim = c(), ylim = c(), asp = 1)
points(locations18_geocode$V1, locations18_geocode$V2, col = "red", cex = .6)
View(locations18_geocode)
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, " Montreal") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, " Montreal") #ensures geocoded to Montreal
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
keyring_create("Rcredentials")
keyring_create("Rcredentials")
keyring_create("Rcredentials")
#keyring_create("Rcredentials")
keyring_unlock("Rcredentials")
#keyring_create("Rcredential")
keyring_unlock("Rcredentials")
#keyring_create("Rcredential")
keyring_unlock("Rcredential")
keyring_create("Rcredential")
keyring_unlock("Rcredential")
key_set("googleapi", keyring ="Rcredential") #API key
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
#sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
#edit data
# I need the csv files to have geographic coordinates.
# I'll geolocate them, but first I have to merge their house numbers and roads
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, " Montreal") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, " Montreal") #ensures geocoded to Montreal
# geolocate the addresses
# this makes two functions to use in geocoding.
# builds url to access API
url <- function(address, return.call = "json", sensor = "false" , key) {
root <- "https://maps.google.com/maps/api/geocode/"
u <- paste(root, return.call, "?address=", address, "&sensor=", sensor, "&key=" ,
key , sep = "")
return(URLencode(u))
}
# Function to parse the results:
geocode <- function(address, api.key , verbose=FALSE) {
if(verbose) cat(address,"\n")
u <- url(address , key = api.key)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
View(locations18_geocode)
View(condamnes2019)
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, " ,Canada") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, " ,Canada") #ensures geocoded to Montreal
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
View(condamnes2018)
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Canada") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, ", Canada") #ensures geocoded to Montreal
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Canada") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, ", Canada") #ensures geocoded to Montreal
View(condamnes2018)
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
#condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Canada") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
#keyring_create("Rcredential") #creates keyring
keyring_unlock("Rcredential") # opens keyring for session
key_set("googleapi", keyring ="Rcredential") #API key
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
View(locations18_geocode)
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
View(condamnes2018)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Canada") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, ", Canada") #ensures geocoded to Montreal
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
#rename columns and join to original dataset
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
View(condamnes2018)
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Montreal") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, ", Montreal") #ensures geocoded to Montreal
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
#rename columns and join to original dataset
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- paste0(condamnes2018$addresses, ", Montreal") #ensures geocoded to Montreal
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
condamnes2019$addresses <- paste0(condamnes2019$addresses, ", Montreal") #ensures geocoded to Montreal
key <- key_get('googleapi', keyring ="Rcredential")
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
#rename columns and join to original dataset
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
# keep this - closes opened keyring session
keyring_lock("Rcredential")
View(exterm)
sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
?FROM_GeoJson
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
library(RCurl)
library(RJSONIO)
library(plyr)
library(mapsapi)
library(keyring)
library(sf)
library(raster)
library(dplyr)
library(spData)
#library(spDataLarge) #not available for this version of R (tutorial on Lovelace)
library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(mapview) # for interactive maps
library(ggplot2) # tidyverse data visualization package
library(shiny)   # for web applications
library(rworldmap)
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
#keyring_create("Rcredential") #creates keyring
keyring_unlock("Rcredential") # opens keyring for session
sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
sanit <- read_sf(dsn = "data/", layer = "inspections-salubrite") #the data source, which in the case of a shapefile is the directory ; and layer - which is the shapefile name, minus extension
library(sf)
sanit <- read_sf(dsn = "~/data/inspections-salubrite.shp") #the data source, which in the case of a shapefile is the directory ; and layer - which is the shapefile name, minus extension
sanit <- read_sf(dsn = "~/data/inspections-salubrite/inspections-salubrite.shp") #the data source, which in the case of a shapefile is the directory ; and layer - which is the shapefile name, minus extension
sanit <- read_sf("~/data/inspections-salubrite/inspections-salubrite.shp") #the data source, which in the case of a shapefile is the directory ; and layer - which is the shapefile name, minus extension
sanit <- read_sf("~/data/inspections-salubrite.shp") #the data source, which in the case of a shapefile is the directory ; and layer - which is the shapefile name, minus extension
sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
#2019
location19 <- condamnes2019 %>% pull(addresses)
locations19_geocode <- ldply(location19, .progress = "text" , function(x) geocode(x , api.key = key))
#rename columns and join to original dataset
names(locations19_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2019 <- condamnes2019 %>% bind_cols(locations19_geocode)
View(condamnes2019)
#add year variable to 2018 and 2019 condamnes datasets
ondamnes2018 <- add_column(condamnes2018, year = 2018)
#add year variable to 2018 and 2019 condamnes datasets
condamnes2018 <- add_column(condamnes2018, year = 2018)
condamnes2018 <- add_column(condamnes2018, year = 2018)
condamnes2019 <- add_column(condamnes2019, year = 2019)
#append condamnes datasets
condamnes18-19 <- bind_rows(condamnes2018, condamnes2019)
#append condamnes datasets
condamnes18and19 <- bind_rows(condamnes2018, condamnes2019)
shinyApp(
ui = fluidPage(
selectInput("region", "Region:",
choices = colnames(WorldPhones)),
plotOutput("phonePlot")
),
server = function(input, output) {
output$phonePlot = renderPlot({
barplot(WorldPhones[,input$region]*1000,
ylab = "Number of Telephones", xlab = "Year")
})
},
options = list(height = 500)
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
library(RCurl)
library(RJSONIO)
library(plyr)
library(mapsapi)
library(keyring)
library(sf)
library(raster)
library(dplyr)
library(spData)
#library(spDataLarge) #not available for this version of R (tutorial on Lovelace)
library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(mapview) # for interactive maps
library(ggplot2) # tidyverse data visualization package
library(shiny)   # for web applications
library(rworldmap)
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
#keyring_create("Rcredential") #creates keyring
keyring_unlock("Rcredential") # opens keyring for session
shinyApp(
ui = fluidPage(
selectInput("region", "Region:",
choices = colnames(WorldPhones)),
plotOutput("phonePlot")
),
server = function(input, output) {
output$phonePlot = renderPlot({
barplot(WorldPhones[,input$region]*1000,
ylab = "Number of Telephones", xlab = "Year")
})
},
options = list(height = 500)
ui = fluidPage(
shinyApp(
ui = fluidPage(
selectInput("region", "Region:",
choices = colnames(WorldPhones)),
plotOutput("phonePlot")
),
server = function(input, output) {
output$phonePlot = renderPlot({
barplot(WorldPhones[,input$region]*1000,
ylab = "Number of Telephones", xlab = "Year")
})
},
options = list(height = 500)
)
