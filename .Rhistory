symbolList,
auto.assign = TRUE,
from = start,
to = end,
)
p_data <- xts(
get(symbolList[1])[, 6]
)
for (i in 2:length(symbolList)){
p_data <- merge.xts(p_data, get(symbolList[i])[, 6])
}
colnames(p_data) <- symbolList
# calculate returns for price and returns data, rename columns
r_data <- na.omit(CalculateReturns(p_data))
colnames(r_data) <- symbolList
list(returns_data = r_data, price_data = p_data)
}
# Stocks for BNS, Air Canada, Shopify, goeasy
my_stocks <- getSymbolData(c("BNS.TO", "AC", "SHOP", "GSY"))
#This makes it a data frame of return data.
return_data <- as.data.frame(my_stocks$returns_data)
#This changes the name to BNS_TO from BNS.TO
names(return_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
#Do the same for price data
#return_data$Date <- index(my_stocks$returns_data)
price_data <- as.data.frame(my_stocks$price_data)
names(price_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
# add column name to first column
price_data <- setNames(cbind(rownames(price_data),
price_data, row.names = NULL),
c("Date", "BNS_TO", "AC", "SHOP", "GSY"))
# Look at plot
plotly::plot_ly(
data = price_data,
y = ~ BNS_TO,
x = ~ Date,
type = "scatter",
mode = "lines",
tickangle = 45 #attempting to format the x-axis.
) %>% layout(
title = "BNS Stock Price",
margin = list(b = 160), #changes x-axis labels
xaxis = list(
type = "date"
),
yaxis = list(
title = "Price"
)
)
# Separate returns data, in xts format.
returns <- my_stocks$returns_data
# Separate price data, in xts format.
price <- my_stocks$price_data
# Calculate the average returns and risk (covariance matrix)
mean_returns <- colMeans(returns)
cov_matrix <- cov(returns)
# Create the portfolio
my_folio <- portfolio.spec(assets = colnames(returns))
# Add constraint
my_folio <- add.constraint(
portfolio = my_folio,
type = "box",
min = 0.05, #these are risk
max = 0.65
)
my_folio <- add.constraint(
portfolio = my_folio,
# The type means the type of investment
type = "leverage",
min_sum = 0.99,  #this is very risky
max_sum = 1.01
)
# Maximize the average returns with return on investment (ROI)
max_return <- add.objective(
portfolio = my_folio,
type = "return",
name = "mean"
)
# Optimization
opt_max_return <- optimize.portfolio(
R = returns,
portfolio = max_return,
optimize_method = "ROI",
trace = TRUE
)
# these print the details on how much I should invest.
#print.default(opt_max_return) #this prints a lot more than the other one.. (after)
#print(opt_max_return)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
)
opt_min_var <- optimize.portfolio(
R = returns,
portfolio = min_var,
optimize_method = "ROI",
trace = TRUE)
# I commented out the print function again to limit the lengthy results.
#print.default(opt_min_var)
#print(opt_min_var)
# Plot optimized minimum var (i.e. risk)
plot(
opt_min_var,
risk.col = "StdDev",
return.col = "mean",
main = "Minimum Variance Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
meansd_ef <- create.EfficientFrontier(
R = returns,
portfolio = my_folio,
type = "mean-sd",
n.portfolios = 10,
)
# Plot efficient frontier!
chart.EfficientFrontier(
meansd_ef,
match.col = "StdDev", # which column to use for risk
type = "l",
RAR.text = "Sharpe Ratio",
tangent.line = FALSE,
chart.assets = TRUE,
labels.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
element.color = "blue"
)
blogdown::serve_site()
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
xaxis = list(
type = "Standard Deviation or Risk"
),
yaxis = list(
title = "Average Returns"
),)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
xaxis = list(
type = "Standard Deviation or Risk"
),
yaxis = list(
title = "Average Returns"
),)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns")
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
#chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns")
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns", outer = T)
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns"),
par(mar = c(6.5, 6.5, 0.5, 0.5), mgp = c(5, 1, 0))
)
?par
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns"),
par(mar = c(5, 4, 4, 2), mgp = c(3, 1, 0))
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk or Standard Deviation", ylab = "Average Returns")
#par(mar = c(5, 4, 4, 2), mgp = c(3, 1, 0))
)
?axis
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk", ylab = "Average Returns"),
par(mar = c(5, 4, 4, 2), mgp = c(3, 1, 0))
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
title(xlab = "Risk", ylab = "Average Returns")
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
#title(xlab = "Risk", ylab = "Average Returns")
)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "Standard Deviation",
return.col = "Average Returns",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
#title(xlab = "Risk", ylab = "Average Returns")
)
?PortfolioAnalytics
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE, #this adds the individual stocks to the figure
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
#title(xlab = "Risk", ylab = "Average Returns")
)
blogdown::serve_site()
# set parameters for the stock dates, as start and end.
getSymbolData <- function(symbolList, start = "2019-06-01", end = "2019-12-31"){
getSymbols(
symbolList,
auto.assign = TRUE,
from = start,
to = end,
)
p_data <- xts(
get(symbolList[1])[, 6]
)
for (i in 2:length(symbolList)){
p_data <- merge.xts(p_data, get(symbolList[i])[, 6])
}
colnames(p_data) <- symbolList
# calculate returns for price and returns data, rename columns
r_data <- na.omit(CalculateReturns(p_data))
colnames(r_data) <- symbolList
list(returns_data = r_data, price_data = p_data)
}
blogdown::serve_site()
knitr::opts_chunk$set(echo = TRUE)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2019.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit')
library(geojsonR)
install.packages("geojsonR")
library(geojsonR)
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
View(condamnes2019)
install.packages("ggmap")
library(ggmap)
library(dplyr)
install.packages("tidyverse")
library(tidyverse)
within(condamnes2018, addresses <- paste(lieu_infraction._no_civique,lieu_infraction._rue, sep=' '))
View(condamnes2018)
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( data[ , cols ] , 1 , paste , collapse = " " )
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
# Initialize the data frame
condamnes2018geo <- data.frame(stringsAsFactors = FALSE)
# Loop through the addresses to get the latitude and longitude of each address and add it to the
# origAddress data frame in new columns lat and lon
for(i in 1:nrow(condamnes2018))
for(i in 1:nrow(condamnes2018))
{
# Print("Working...")
result <- geocode(condamnes2018$addresses[i], output = "latlona", source = "google")
condamnes2018$lon[i] <- as.numeric(result[1])
condamnes2018$lat[i] <- as.numeric(result[2])
cond
for(i in 1:nrow(condamnes2018))
{
# Print("Working...")
result <- geocode(condamnes2018$addresses[i], output = "latlona", source = "google")
condamnes2018$lon[i] <- as.numeric(result[1])
condamnes2018$lat[i] <- as.numeric(result[2])
condamnes2018$geoAddress[i] <- as.character(result[3])
}
# Write a CSV file containing origAddress to the working directory
write.csv(condamnes2018, "condamnes2018geo.csv", row.names=FALSE)
View(condamnes2018geo)
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
knitr::opts_chunk$set(echo = TRUE)
library(geojsonR)
library(ggmap)
library(dplyr)
library(tidyverse)
condamnes2018 <- read.csv(file = 'data/liste_des_contrevenants_condamnes_annee_2018.csv')
condamnes2019 <- read.csv(file = 'data/liste-des-contrevenants-condamnes-annee-2019.csv')
exterm <- FROM_GeoJson('data/declarations-exterminations-punaises-de-lit.geojson')
#sanit <- FROM_GeoJson('data/inspections-salubrite.geojson')
#edit data
# I need the csv files to have geographic coordinates.
# I'll geolocate them, but first I have to merge their house numbers and roads
# makes one column that is 'addresses' for the 2018 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2018$addresses <- apply( condamnes2018[ , cols ] , 1 , paste , collapse = " " )
# makes one column that is 'addresses' for the 2019 data
cols <- c( 'lieu_infraction._no_civique' , 'lieu_infraction._rue')
condamnes2019$addresses <- apply( condamnes2019[ , cols ] , 1 , paste , collapse = " " )
# geolocate the addresses
# Initialize the data frame
condamnes2018geo <- data.frame(stringsAsFactors = FALSE)
# Loop through the addresses to get the latitude and longitude of each address and add it to the
# origAddress data frame in new columns lat and lon
for(i in 1:nrow(condamnes2018))
{
# Print("Working...")
result <- geocode(condamnes2018$addresses[i], output = "latlona", source = "google")
condamnes2018$lon[i] <- as.numeric(result[1])
condamnes2018$lat[i] <- as.numeric(result[2])
condamnes2018$geoAddress[i] <- as.character(result[3])
}
?register_google
# geolocate the addresses
# google api: AIzaSyDdNyvzi87jUh-E8h_ce2MbPnwvcuEIme0
# https://www.googleapis.com/geolocation/v1/geolocate?key=YOUR_API_KEY
register_google(key = "AIzaSyDdNyvzi87jUh-E8h_ce2MbPnwvcuEIme0", write = TRUE)
devtools::install_github("dkahle/ggmap")
if(!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("dkahle/ggmap")
library(RCurl)
install.packages(c("RCurl", "RJSONIO", "plyr"))
library(RCurl)
library(RJSONIO)
library(plyr)
# builds url to access API
url <- function(address, return.call = "json", sensor = "false") {
root <- "http://maps.google.com/maps/api/geocode/"
u <- paste(root, return.call, "?address=", address, "&sensor=", sensor, sep = "")
return(URLencode(u))
}
install.packages("mapsapi")
library(mapsapi)
?mapspai
?mapsapi
pnt = mp_get_points(condamnes2019)
addresses <- condamnes2018 %>% pull(address)
library(tidyverse)
addresses <- condamnes2018%>% pull(address)
addresses <- condamnes2018 %>% pull(addresses)
# this separates out the address column
addresses18 <- condamnes2018 %>% pull(addresses)
# prep data
# this separates out the address column
address <- condamnes2018 %>% pull(addresses)
#Function to parse the results:
geoCode <- function(address,verbose=FALSE) {
if(verbose) cat(address,"\n")
u <- url(address)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
# prep data
# this separates out the address column
address18 <- condamnes2018 %>% pull(addresses)
# Function to parse the results:
geoCode <- function(address18,verbose=FALSE) {
if(verbose) cat(address18,"\n")
u <- url(address18)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
# builds url to access API
url <- function(address, return.call = "json", sensor = "false" , key) {
root <- "https://maps.google.com/maps/api/geocode/"
u <- paste(root, return.call, "?address=", address, "&sensor=", sensor, "&key=" ,
key , sep = "")
return(URLencode(u))
}
# Function to parse the results:
geocode <- function(address, api.key , verbose=FALSE) {
if(verbose) cat(address,"\n")
u <- url(address , key = api.key)
doc <- getURL(u)
x <- fromJSON(doc,simplify = FALSE)
if(x$status=="OK") {
lat <- x$results[[1]]$geometry$location$lat
lng <- x$results[[1]]$geometry$location$lng
location_type  <- x$results[[1]]$geometry$location_type
formatted_address  <- x$results[[1]]$formatted_address
return(c(lat, lng, location_type, formatted_address))
Sys.sleep(0.5)
} else {
return(c(NA,NA,NA, NA))
}
}
#abe sent this.
key <- "AIzaSyDdNyvzi87jUh-E8h_ce2MbPnwvcuEIme0"
location18 <- condamnes2018 %>% pull(addresses)
locations18_geocode <- ldply(location18, .progress = "text" , function(x) geocode(x , api.key = key))
names(locations_geocode) <- c("lat","lng","location_type", "formatted")
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
names(locations18_geocode) <- c("lat","lng","location_type", "formatted")
condamnes2018 <- condamnes2018 %>% bind_cols(locations18_geocode)
