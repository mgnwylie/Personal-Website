"> 75th percentile Gini Coefficient"),
sizes = c(5, 10, 15, 20),
title = "title") %>%
#hide layers 2001, 2006, and 2011 for when the map opens.
hideGroup("Gini Coefficient 2001") %>%
hideGroup("Gini Coefficient 2006") %>%
hideGroup("Gini Coefficient 2011")
leaflet(tf) %>%
addProviderTiles(provider = providers$CartoDB.Positron) %>%
#addCircleMarkers defines size in terms of metres - they're too similar in size
addCircleMarkers(#radius = 50*(qlogis(point.locations.sf.transform$gini01)),
color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini01_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini01, digits = 2) , sep = ", " ),
group = "Gini Coefficient 2001") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini06_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini06, digits = 2) , sep = ", "),
group = "Gini Coefficient 2006") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini11_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini11, digits = 2) , sep = ", " ) ,
group = "Gini Coefficient 2011") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini16_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini16, digits = 2), sep = ", " ),
group = "Gini Coefficient 2016") %>%
#addLayersControl command breaks each year into one selection option.
addLayersControl(
overlayGroups = c("Gini Coefficient 2001", "Gini Coefficient 2006" ,
"Gini Coefficient 2011" , "Gini Coefficient 2016")) %>%
#add legends that appear/disappear with toggle
addLegendCustom(colors = ("#3182bd"),
labels = c("< 25th percentile Gini Coefficient",
"50th percentile Gini Coefficient",
"75th percentile Gini Coefficient",
"> 75th percentile Gini Coefficient"),
sizes = c(5, 10, 15, 20),
position = ("topright"),
title = "title") %>%
#hide layers 2001, 2006, and 2011 for when the map opens.
hideGroup("Gini Coefficient 2001") %>%
hideGroup("Gini Coefficient 2006") %>%
hideGroup("Gini Coefficient 2011")
leaflet(tf) %>%
addProviderTiles(provider = providers$CartoDB.Positron) %>%
#addCircleMarkers defines size in terms of metres - they're too similar in size
addCircleMarkers(#radius = 50*(qlogis(point.locations.sf.transform$gini01)),
color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini01_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini01, digits = 2) , sep = ", " ),
group = "Gini Coefficient 2001") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini06_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini06, digits = 2) , sep = ", "),
group = "Gini Coefficient 2006") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini11_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini11, digits = 2) , sep = ", " ) ,
group = "Gini Coefficient 2011") %>%
addCircleMarkers( color = "#3182bd" ,
fillColor = "#9ecae1" ,
fillOpacity = .6 ,
radius = ~ gini16_bin*2 ,
weight = 2 ,
label = ~paste(CMANAME , round(gini16, digits = 2), sep = ", " ),
group = "Gini Coefficient 2016") %>%
#addLayersControl command breaks each year into one selection option.
addLayersControl(
overlayGroups = c("Gini Coefficient 2001", "Gini Coefficient 2006" ,
"Gini Coefficient 2011" , "Gini Coefficient 2016")) %>%
#add legends that appear/disappear with toggle
addLegendCustom(colors = ("#3182bd"),
labels = c("< 25th percentile Gini Coefficient",
"50th percentile Gini Coefficient",
"75th percentile Gini Coefficient",
"> 75th percentile Gini Coefficient"),
sizes = c(5, 10, 15, 20),
position = "topright",
title = "title") %>%
#hide layers 2001, 2006, and 2011 for when the map opens.
hideGroup("Gini Coefficient 2001") %>%
hideGroup("Gini Coefficient 2006") %>%
hideGroup("Gini Coefficient 2011")
knitr::opts_chunk$set(echo = F )
# echo = FALSE doesn't show the R code in the post.
# eval = FALSE to omit results
library(tidyverse)
library(geojsonio)
library(sf)
#library(mapview)
library(leaflet)
library(shiny)
library(rgdal)
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown:::new_post_addin()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
webshot::install_phantomjs()
tinytex::install_tinytex()
knitr::opts_chunk$set(echo = F, message = F, warning = F)
library(PortfolioAnalytics)
library(PerformanceAnalytics)
library(quantmod)
library(zoo)
library(plotly)
library(tidyquant)
library(dplyr)
library(DEoptim)
library(ROI)
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
library(xts)
# set parameters for the stock dates, as start and end.
getSymbolData <- function(symbolList, start = "2019-06-01", end = "2019-12-31"){
getSymbols(
symbolList,
auto.assign = TRUE,
from = start,
to = end,
)
p_data <- xts(
get(symbolList[1])[, 6]
)
for (i in 2:length(symbolList)){
p_data <- merge.xts(p_data, get(symbolList[i])[, 6])
}
colnames(p_data) <- symbolList
# calculate returns for price and returns data, rename columns
r_data <- na.omit(CalculateReturns(p_data))
colnames(r_data) <- symbolList
list(returns_data = r_data, price_data = p_data)
}
# Stocks for BNS, Air Canada, Shopify, goeasy
my_stocks <- getSymbolData(c("BNS.TO", "AC", "SHOP", "GSY"))
#This makes it a data frame of return data.
return_data <- as.data.frame(my_stocks$returns_data)
#This changes the name to BNS_TO from BNS.TO
names(return_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
#Do the same for price data
#return_data$Date <- index(my_stocks$returns_data)
price_data <- as.data.frame(my_stocks$price_data)
names(price_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
# Look at plot
plotly::plot_ly(
data = price_data,
y = ~ BNS_TO,
type = "scatter",
mode = "lines"
) %>% layout(
title = title,
xaxis = list(
type = "date"
),
yaxis = list(
title = "Price"
)
)
# Separate returns data, in xts format.
returns <- my_stocks$returns_data
# Separate price data, in xts format.
price <- my_stocks$price_data
# Calculate the average returns and risk (covariance matrix)
mean_returns <- colMeans(returns)
cov_matrix <- cov(returns)
# Create the portfolio
my_folio <- portfolio.spec(assets = colnames(returns))
# Add constraint
my_folio <- add.constraint(
portfolio = my_folio,
type = "box",
min = 0.05, #these are risk
max = 0.65
)
my_folio <- add.constraint(
portfolio = my_folio,
# The type means the type of investment
type = "leverage",
min_sum = 0.99,  #this is very risky
max_sum = 1.01
)
# Maximize the average returns with return on investment (ROI)
max_return <- add.objective(
portfolio = my_folio,
type = "return",
name = "mean"
)
# Optimization
opt_max_return <- optimize.portfolio(
R = returns,
portfolio = max_return,
optimize_method = "ROI",
trace = TRUE
)
# these print the details on how much I should invest.
#print.default(opt_max_return) #this prints a lot more than the other one.. (after)
#print(opt_max_return)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Minimum Variance Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
opt_min_var <- optimize.portfolio(
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
opt_min_var <- optimize.portfolio(
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
)
opt_min_var <- optimize.portfolio(
R = returns,
portfolio = min_var,
optimize_method = "ROI",
trace = TRUE)
)
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
)
opt_min_var <- optimize.portfolio(
R = returns,
portfolio = min_var,
optimize_method = "ROI",
trace = TRUE))
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
)
opt_min_var <- optimize.portfolio(
R = returns,
portfolio = min_var,
optimize_method = "ROI",
trace = TRUE)
# I commented out the print function again to limit the lengthy results.
#print.default(opt_min_var)
#print(opt_min_var)
# Plot optimized minimum var (i.e. risk)
plot(
opt_min_var,
risk.col = "StdDev",
return.col = "mean",
main = "Minimum Variance Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
meansd_ef <- create.EfficientFrontier(
R = returns,
portfolio = my_folio,
type = "mean-sd",
n.portfolios = 10,
)
# Plot efficient frontier
chart.EfficientFrontier(
meansd_ef,
match.col = "StdDev", # which column to use for risk
type = "l",
RAR.text = "Sharpe Ratio",
tangent.line = FALSE,
chart.assets = TRUE,
labels.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
element.color = "blue"
)
meansd_ef <- create.EfficientFrontier(
R = returns,
portfolio = my_folio,
type = "mean-sd",
n.portfolios = 10,
)
# Plot efficient frontier
chart.EfficientFrontier(
meansd_ef,
match.col = "StdDev", # which column to use for risk
type = "l",
RAR.text = "Sharpe Ratio",
tangent.line = FALSE,
chart.assets = TRUE,
labels.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
element.color = "blue"
)
knitr::opts_chunk$set(echo = F, message = F, warning = F)
library(PortfolioAnalytics)
library(PerformanceAnalytics)
library(quantmod)
library(zoo)
library(plotly)
library(tidyquant)
library(dplyr)
library(DEoptim)
library(ROI)
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
library(xts)
# set parameters for the stock dates, as start and end.
getSymbolData <- function(symbolList, start = "2019-06-01", end = "2019-12-31"){
getSymbols(
symbolList,
auto.assign = TRUE,
from = start,
to = end,
)
p_data <- xts(
get(symbolList[1])[, 6]
)
for (i in 2:length(symbolList)){
p_data <- merge.xts(p_data, get(symbolList[i])[, 6])
}
colnames(p_data) <- symbolList
# calculate returns for price and returns data, rename columns
r_data <- na.omit(CalculateReturns(p_data))
colnames(r_data) <- symbolList
list(returns_data = r_data, price_data = p_data)
}
# Stocks for BNS, Air Canada, Shopify, goeasy
my_stocks <- getSymbolData(c("BNS.TO", "AC", "SHOP", "GSY"))
#This makes it a data frame of return data.
return_data <- as.data.frame(my_stocks$returns_data)
#This changes the name to BNS_TO from BNS.TO
names(return_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
#Do the same for price data
#return_data$Date <- index(my_stocks$returns_data)
price_data <- as.data.frame(my_stocks$price_data)
names(price_data) <- c("BNS_TO", "AC", "SHOP", "GSY")
# Look at plot
plotly::plot_ly(
data = price_data,
y = ~ BNS_TO,
type = "scatter",
mode = "lines"
) %>% layout(
title = title,
xaxis = list(
type = "date"
),
yaxis = list(
title = "Price"
)
)
# Separate returns data, in xts format.
returns <- my_stocks$returns_data
# Separate price data, in xts format.
price <- my_stocks$price_data
# Calculate the average returns and risk (covariance matrix)
mean_returns <- colMeans(returns)
cov_matrix <- cov(returns)
# Create the portfolio
my_folio <- portfolio.spec(assets = colnames(returns))
# Add constraint
my_folio <- add.constraint(
portfolio = my_folio,
type = "box",
min = 0.05, #these are risk
max = 0.65
)
my_folio <- add.constraint(
portfolio = my_folio,
# The type means the type of investment
type = "leverage",
min_sum = 0.99,  #this is very risky
max_sum = 1.01
)
# Maximize the average returns with return on investment (ROI)
max_return <- add.objective(
portfolio = my_folio,
type = "return",
name = "mean"
)
# Optimization
opt_max_return <- optimize.portfolio(
R = returns,
portfolio = max_return,
optimize_method = "ROI",
trace = TRUE
)
# these print the details on how much I should invest.
#print.default(opt_max_return) #this prints a lot more than the other one.. (after)
#print(opt_max_return)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Minimum Variance Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
# Minimize variance (risk) with ROI
min_var <- add.objective(
portfolio = my_folio,
type = "risk", #risk
name = "var"
)
opt_min_var <- optimize.portfolio(
R = returns,
portfolio = min_var,
optimize_method = "ROI",
trace = TRUE)
# I commented out the print function again to limit the lengthy results.
#print.default(opt_min_var)
#print(opt_min_var)
# Plot optimized minimum var (i.e. risk)
plot(
opt_min_var,
risk.col = "StdDev",
return.col = "mean",
main = "Minimum Variance Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
meansd_ef <- create.EfficientFrontier(
R = returns,
portfolio = my_folio,
type = "mean-sd",
n.portfolios = 10,
)
# Plot efficient frontier
chart.EfficientFrontier(
meansd_ef,
match.col = "StdDev", # which column to use for risk
type = "l",
RAR.text = "Sharpe Ratio",
tangent.line = FALSE,
chart.assets = TRUE,
labels.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004),
element.color = "blue"
)
blogdown::serve_site()
blogdown::serve_site()
blogdown::new_post()
install.packages("blogdown")
blogdown::new_post()
blogdown::new_post("Convicted landlords of Montreal: exploring new open housing data")
blogdown::install_hugo()
blogdown::new_post("Convicted landlords of Montreal: exploring new open housing data")
install.packages(c("DEoptim", "dplyr", "PerformanceAnalytics", "plotly", "PortfolioAnalytics", "quantmod", "ROI", "ROI.plugin.glpk", "ROI.plugin.quadprog", "tidyquant", "xts", "zoo"))
install.packages(c("dplyr", "httr", "repmis"))
install.packages("plotly")
knitr::opts_chunk$set(echo = F, message = F, warning = F)
library(PortfolioAnalytics)
library(PerformanceAnalytics)
library(quantmod)
library(zoo)
library(plotly)
library(tidyquant)
library(dplyr)
library(DEoptim)
library(ROI)
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
library(xts)
# Plot optimized maximum mean (i.e. return?)
plot(
opt_max_return,
risk.col = "StdDev",
return.col = "mean",
main = "Low Risk Optimization",
chart.assets = TRUE,
xlim = c(-0.5, 1),
ylim = c(-0.002, 0.004)
)
